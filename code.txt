// crypto.rs
//! Keccak-256 hashing utilities.

use sha3::{Digest, Keccak256};

/// Compute Keccak-256 hash of the given data, returning a 32-byte array.
pub fn keccak256(data: &[u8]) -> [u8; 32] {
    let mut hasher = Keccak256::new();
    hasher.update(data);
    let result = hasher.finalize();
    let mut out = [0u8; 32];
    out.copy_from_slice(&result);
    out
}

// field.rs
//! Finite-field wrapper for BN254 Fr, compatible with Arkworks 0.5.

use ark_bn254::Fr as ArkFr;
use ark_ff::{Field, Zero, PrimeField};
use ark_serialize::CanonicalSerialize;
use hex;
use std::ops::{Add, Mul, Neg, Sub};
use ark_ff::BigInteger256;

/*────────────────────────────  OddLength を回避するヘルパ  ──────────────────────────*/
/// "0x…" を剥がし、奇数桁なら先頭に '0' を付けて **必ず偶数桁** にする。
#[inline(always)]
fn normalize_hex(s: &str) -> String {
    let raw = s.trim_start_matches("0x");
    if raw.len() & 1 == 1 {
        let mut out = String::with_capacity(raw.len() + 1);
        out.push('0');
        out.push_str(raw);
        out
    } else {
        raw.to_owned()
    }
}

/*────────────────────────────  Fr wrapper  ──────────────────────────*/

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Fr(pub ArkFr);

impl Fr {
    /*--------- constructors ---------*/

    /// Construct from u64.
    pub fn from_u64(x: u64) -> Self {
        Fr(ArkFr::from(x))
    }

    /// Construct from hex string (with or without 0x prefix).
    /// 偶数桁に正規化してから `hex::decode` するので OddLength 例外は起こさない。
    pub fn from_str(s: &str) -> Self {
        let bytes = hex::decode(normalize_hex(s)).expect("hex decode failed");
        let mut padded = [0u8; 32];
        let offset = 32 - bytes.len();
        padded[offset..].copy_from_slice(&bytes);
        Self::from_bytes(&padded)
    }

    /// Construct from a 32-byte big-endian array.
    pub fn from_bytes(bytes: &[u8; 32]) -> Self {
        // ark-ff は LE を取るので BE → LE
        let mut tmp = *bytes;
        tmp.reverse();
        Fr(ArkFr::from_le_bytes_mod_order(&tmp))
    }

    /*--------- conversions ---------*/

    /// Convert to 32-byte big-endian representation.
    #[inline(always)]
    pub fn to_bytes(&self) -> [u8; 32] {
        let bi: BigInteger256 = self.0.into_bigint();
        let mut out = [0u8; 32];
        for (i, limb) in bi.0.iter().rev().enumerate() {
            out[i * 8..(i + 1) * 8].copy_from_slice(&limb.to_be_bytes());
        }
        out
    }

    /// Convert to "0x…" hex string（常に 64 桁）— デバッグ用。
    pub fn to_hex(&self) -> String {
        format!("0x{}", hex::encode(self.to_bytes()))
    }

    /*--------- math helpers ---------*/

    pub fn inverse(&self) -> Self {
        Fr(self.0.inverse().unwrap())
    }

    pub fn zero() -> Self {
        Fr(ArkFr::zero())
    }

    pub fn one() -> Self {
        Fr(ArkFr::ONE)
    }

    pub fn pow(&self, exp: u128) -> Self {
        let mut bits = [0u64; 4];
        bits[0] = exp as u64;
        Fr(self.0.pow(bits))
    }

    pub fn is_zero(&self) -> bool {
        self.0.is_zero()
    }

    pub fn div(&self, rhs: &Fr) -> Self {
        Fr(self.0 * rhs.0.inverse().unwrap())
    }
}

/*────────────────────────────  Operators / Serialize  ──────────────────────────*/

impl Add for Fr {
    type Output = Fr;
    fn add(self, rhs: Fr) -> Fr {
        Fr(self.0 + rhs.0)
    }
}

impl Sub for Fr {
    type Output = Fr;
    fn sub(self, rhs: Fr) -> Fr {
        Fr(self.0 - rhs.0)
    }
}

impl Mul for Fr {
    type Output = Fr;
    fn mul(self, rhs: Fr) -> Fr {
        Fr(self.0 * rhs.0)
    }
}

impl Neg for Fr {
    type Output = Fr;
    fn neg(self) -> Fr {
        Fr(-self.0)
    }
}

impl CanonicalSerialize for Fr {
    fn serialize_with_mode<W: std::io::Write>(
        &self,
        mut writer: W,
        _compress: ark_serialize::Compress,
    ) -> Result<(), ark_serialize::SerializationError> {
        self.0.serialize_compressed(&mut writer)
    }

    fn serialized_size(&self, _compress: ark_serialize::Compress) -> usize {
        self.0.compressed_size()
    }
}

// src/lib.rs

pub mod crypto;
pub mod field;
pub mod relations;
pub mod transcript;
pub mod types;
pub mod utils;
pub mod verifier;
pub mod sumcheck;
pub mod shplonk;

pub use utils::load_proof_and_public_inputs;
pub use verifier::HonkVerifier;

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs::File;
    use std::io::Read;
    use std::path::Path;

    #[test]
    fn test_simple_proof() -> Result<(), String> {
        // 1) Load proof+inputs
        let fixtures = Path::new("tests/fixtures");
        let mut buf = Vec::new();
        File::open(fixtures.join("simple_proof.bin"))
            .map_err(|e| e.to_string())?
            .read_to_end(&mut buf)
            .map_err(|e| e.to_string())?;
        let (pub_inputs, proof_bytes) = load_proof_and_public_inputs(&buf);

        // 2) Load VK JSON (hex strings)
        let vk_path = fixtures.join("simple_vk.json");
        // 3) Verify
        let verifier = HonkVerifier::new(vk_path.to_str().unwrap());
        // serialize pub inputs
        let mut inp_bytes = Vec::new();
        for fr in pub_inputs {
            let mut b = [0u8; 32];
            b.copy_from_slice(&fr.to_bytes());
            inp_bytes.push(b.to_vec());
        }
        verifier.verify(&proof_bytes, &inp_bytes)?;
        println!("✅ Verification succeeded");
        Ok(())
    }
}

// relations.rs
//! Relation evaluation accumulation for UltraHonk.
//!
//! This module accumulates all of the UltraHonk relations (arithmetic, permutation,
//! lookup, range, elliptic, auxiliary, Poseidon external/internal) into a single
//! scalar which is then batched with the alpha challenges.

use crate::field::Fr;
use crate::types::{RelationParameters, Wire};
use std::ops::Neg;

/// Precomputed NEG_HALF = (p - 1)/2 in BN254 scalar field.
fn neg_half() -> Fr {
    Fr::from_str("0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000")
}

/// Internal matrix diagonal values for Poseidon hash
fn internal_matrix_diagonal() -> [Fr; 4] {
    [
        Fr::from_str("0x10dc6e9c006ea38b04b1e03b4bd9490c0d03f98929ca1d7fb56821fd19d3b6e7"),
        Fr::from_str("0x0c28145b6a44df3e0149b3d0a30b3bb599df9756d4dd9b84a86b38cfb45a740b"),
        Fr::from_str("0x00544b8338791518b2c7645a50392798b21f75bb60e3596170067d00141cac15"),
        Fr::from_str("0x222c01175718386f2e2e82eb122789e352e105a3b8fa852613bc534433ee428b"),
    ]
}

/// Helper to index into the wire array.
fn wire(vals: &[Fr], w: Wire) -> Fr {
    vals[w.index()]
}

/// Accumulate the two arithmetic subrelations (indices 0 and 1).
fn accumulate_arithmetic(vals: &[Fr], out: &mut [Fr], d: Fr) {
    // Subrelation 0: quadratic gate combination
    {
        let q = wire(vals, Wire::QArith);
        let mut acc = (q - Fr::from_u64(3))
            * wire(vals, Wire::Qm)
            * wire(vals, Wire::Wr)
            * wire(vals, Wire::Wl)
            * neg_half();
        acc = acc
            + wire(vals, Wire::Ql) * wire(vals, Wire::Wl)
            + wire(vals, Wire::Qr) * wire(vals, Wire::Wr)
            + wire(vals, Wire::Qo) * wire(vals, Wire::Wo)
            + wire(vals, Wire::Q4) * wire(vals, Wire::W4)
            + wire(vals, Wire::Qc);
        acc = (acc + (q - Fr::one()) * wire(vals, Wire::W4Shift)) * q * d;
        out[0] = acc;
    }
    // Subrelation 1: indicator for q_m
    {
        let q = wire(vals, Wire::QArith);
        let mut acc = wire(vals, Wire::Wl)
            + wire(vals, Wire::W4)
            - wire(vals, Wire::WlShift)
            + wire(vals, Wire::Qm);
        acc = acc
            * (q - Fr::from_u64(2))
            * (q - Fr::from_u64(1))
            * q
            * d;
        out[1] = acc;
    }
}

/// Accumulate the two permutation subrelations (indices 2 and 3).
fn accumulate_permutation(vals: &[Fr], rp: &RelationParameters, out: &mut [Fr], d: Fr) {
    let mut num = wire(vals, Wire::Wl) + wire(vals, Wire::Id1) * rp.beta + rp.gamma;
    num = num
        * (wire(vals, Wire::Wr) + wire(vals, Wire::Id2) * rp.beta + rp.gamma)
        * (wire(vals, Wire::Wo) + wire(vals, Wire::Id3) * rp.beta + rp.gamma)
        * (wire(vals, Wire::W4) + wire(vals, Wire::Id4) * rp.beta + rp.gamma);

    let mut den = wire(vals, Wire::Wl) + wire(vals, Wire::Sigma1) * rp.beta + rp.gamma;
    den = den
        * (wire(vals, Wire::Wr) + wire(vals, Wire::Sigma2) * rp.beta + rp.gamma)
        * (wire(vals, Wire::Wo) + wire(vals, Wire::Sigma3) * rp.beta + rp.gamma)
        * (wire(vals, Wire::W4) + wire(vals, Wire::Sigma4) * rp.beta + rp.gamma);

    out[2] = (wire(vals, Wire::ZPerm) + wire(vals, Wire::LagrangeFirst)) * num
        - (wire(vals, Wire::ZPermShift) + wire(vals, Wire::LagrangeLast) * rp.public_inputs_delta)
            * den;
    out[2] = out[2] * d;
    out[3] = wire(vals, Wire::LagrangeLast) * wire(vals, Wire::ZPermShift) * d;
}

/// Accumulate the two lookup log‐derivative subrelations (indices 4 and 5).
fn accumulate_lookup(vals: &[Fr], rp: &RelationParameters, out: &mut [Fr], d: Fr) {
    let write_term = wire(vals, Wire::Table1)
        + rp.gamma
        + wire(vals, Wire::Table2) * rp.eta
        + wire(vals, Wire::Table3) * rp.eta_two
        + wire(vals, Wire::Table4) * rp.eta_three;

    let derived_entry_2 =
        wire(vals, Wire::Wr) + wire(vals, Wire::Qm) * wire(vals, Wire::WrShift);
    let derived_entry_3 =
        wire(vals, Wire::Wo) + wire(vals, Wire::Qc) * wire(vals, Wire::WoShift);
    
    let read_term = wire(vals, Wire::Wl) + rp.gamma
        + wire(vals, Wire::Qr) * wire(vals, Wire::WlShift)
        + derived_entry_2 * rp.eta
        + derived_entry_3 * rp.eta_two
        + wire(vals, Wire::Qo) * rp.eta_three;

    let inv = wire(vals, Wire::LookupInverses);
    let inv_exists = wire(vals, Wire::LookupReadTags)
        + wire(vals, Wire::QLookup)
        - wire(vals, Wire::LookupReadTags) * wire(vals, Wire::QLookup);

    out[4] = (read_term * write_term * inv - inv_exists) * d;
    out[5] = wire(vals, Wire::QLookup) * (write_term * inv)
         - wire(vals, Wire::LookupReadCounts) * (read_term * inv);
}

/// Accumulate the four range‐check subrelations (indices 6..9).
fn accumulate_range(vals: &[Fr], out: &mut [Fr], d: Fr) {
    let deltas = [
        wire(vals, Wire::Wr) - wire(vals, Wire::Wl),
        wire(vals, Wire::Wo) - wire(vals, Wire::Wr),
        wire(vals, Wire::W4) - wire(vals, Wire::Wo),
        wire(vals, Wire::WlShift) - wire(vals, Wire::W4),
    ];
    let negs = [Fr::from_u64(1).neg(), Fr::from_u64(2).neg(), Fr::from_u64(3).neg()];
    for i in 0..4 {
        let mut acc = deltas[i];
        for &n in &negs {
            acc = acc * (deltas[i] + n);
        }
        out[6 + i] = acc * wire(vals, Wire::QRange) * d;
    }
}

/// Accumulate elliptic‐curve subrelations (indices 10..11).
fn accumulate_elliptic(vals: &[Fr], out: &mut [Fr], d: Fr) {
    let x1 = wire(vals, Wire::Wr);
    let y1 = wire(vals, Wire::Wo);
    let x2 = wire(vals, Wire::WlShift);
    let y2 = wire(vals, Wire::W4Shift);
    let x3 = wire(vals, Wire::WrShift);
    let y3 = wire(vals, Wire::WoShift);

    let q_sign = wire(vals, Wire::Ql);
    let q_double = wire(vals, Wire::Qm);
    let q_gate = wire(vals, Wire::QElliptic);

    let delta_x = x2 - x1;
    let y1_sq = y1 * y1;

    let x_add_id = {
        let y2_sq = y2 * y2;
        let y1y2 = y1 * y2 * q_sign;
        (x3 + x2 + x1) * delta_x * delta_x - y2_sq - y1_sq + y1y2 + y1y2
    };
    let y_add_id = {
        let y_diff = y2 * q_sign - y1;
        (y1 + y3) * delta_x + (x3 - x1) * y_diff
    };

    const B_NEG: u64 = 17;
    let b_neg = Fr::from_u64(B_NEG);

    let x_double_id = {
        let x_pow_4 = (y1_sq + b_neg) * x1;
        let y1_sqr_mul_4 = y1_sq + y1_sq + y1_sq + y1_sq;
        let x_pow_4_mul_9 = x_pow_4 * Fr::from_u64(9);
        (x3 + x1 + x1) * y1_sqr_mul_4 - x_pow_4_mul_9
    };
    let y_double_id = {
        let x1_sqr_mul_3 = (x1 + x1 + x1) * x1;
        x1_sqr_mul_3 * (x1 - x3) - (y1 + y1) * (y1 + y3)
    };

    let add_factor = (Fr::one() - q_double) * q_gate * d;
    let double_factor = q_double * q_gate * d;

    out[10] = x_add_id * add_factor + x_double_id * double_factor;
    out[11] = y_add_id * add_factor + y_double_id * double_factor;
}

/// Accumulate auxiliary subrelations (indices 12..17).
fn accumulate_aux(vals: &[Fr], rp: &RelationParameters, out: &mut [Fr], d: Fr) {
    fn limb_size() -> Fr {
        Fr::from_str("0x10000000000000000")
    }
    fn sublimb_shift() -> Fr {
        Fr::from_u64(1 << 14)
    }

    let mut limb_subproduct = wire(vals, Wire::Wl) * wire(vals, Wire::WrShift)
        + wire(vals, Wire::WlShift) * wire(vals, Wire::Wr);

    let mut gate2 = wire(vals, Wire::Wl) * wire(vals, Wire::W4)
        + wire(vals, Wire::Wr) * wire(vals, Wire::Wo)
        - wire(vals, Wire::WoShift);
    gate2 = gate2 * limb_size() - wire(vals, Wire::W4Shift) + limb_subproduct;
    gate2 = gate2 * wire(vals, Wire::Q4);

    limb_subproduct = limb_subproduct * limb_size()
        + wire(vals, Wire::WlShift) * wire(vals, Wire::WrShift);

    let gate1 = (limb_subproduct - (wire(vals, Wire::Wo) + wire(vals, Wire::W4)))
        * wire(vals, Wire::Qo);

    let gate3 = (limb_subproduct + wire(vals, Wire::W4)
        - (wire(vals, Wire::WoShift) + wire(vals, Wire::W4Shift)))
        * wire(vals, Wire::Qm);

    let non_native_field_identity = (gate1 + gate2 + gate3) * wire(vals, Wire::Qr);

    let mut limb_acc_1 = wire(vals, Wire::WrShift) * sublimb_shift() + wire(vals, Wire::WlShift);
    limb_acc_1 = limb_acc_1 * sublimb_shift() + wire(vals, Wire::Wo);
    limb_acc_1 = limb_acc_1 * sublimb_shift() + wire(vals, Wire::Wr);
    limb_acc_1 = limb_acc_1 * sublimb_shift() + wire(vals, Wire::Wl);
    limb_acc_1 = (limb_acc_1 - wire(vals, Wire::W4)) * wire(vals, Wire::Q4);

    let mut limb_acc_2 = wire(vals, Wire::WoShift) * sublimb_shift() + wire(vals, Wire::WrShift);
    limb_acc_2 = limb_acc_2 * sublimb_shift() + wire(vals, Wire::WlShift);
    limb_acc_2 = limb_acc_2 * sublimb_shift() + wire(vals, Wire::W4);
    limb_acc_2 = limb_acc_2 * sublimb_shift() + wire(vals, Wire::Wo);
    limb_acc_2 = (limb_acc_2 - wire(vals, Wire::W4Shift)) * wire(vals, Wire::Qm);

    let limb_acc_identity = (limb_acc_1 + limb_acc_2) * wire(vals, Wire::Qo);

    let mut mr = wire(vals, Wire::Wo) * rp.eta_three
        + wire(vals, Wire::Wr) * rp.eta_two
        + wire(vals, Wire::Wl) * rp.eta
        + wire(vals, Wire::Qc);
    let partial = mr;
    mr = mr - wire(vals, Wire::W4);

    let idx_delta = wire(vals, Wire::WlShift) - wire(vals, Wire::Wl);
    let rec_delta = wire(vals, Wire::W4Shift) - wire(vals, Wire::W4);

    let idx_inc = idx_delta * idx_delta - idx_delta;
    let adj_match  = (Fr::one() - idx_delta) * rec_delta;

    out[13] = adj_match * wire(vals, Wire::Ql) * wire(vals, Wire::Qr) * wire(vals, Wire::QAux) * d;
    out[14] = idx_inc * wire(vals, Wire::Ql) * wire(vals, Wire::Qr) * wire(vals, Wire::QAux) * d;

    let access_type = wire(vals, Wire::W4) - partial;
    let access_check = access_type * access_type - access_type;

    let mut next_gate = wire(vals, Wire::WoShift) * rp.eta_three
        + wire(vals, Wire::WrShift) * rp.eta_two
        + wire(vals, Wire::WlShift) * rp.eta;
    next_gate = wire(vals, Wire::W4Shift) - next_gate;

    let val_delta = wire(vals, Wire::WoShift) - wire(vals, Wire::Wo);
    let adj_match2 = (Fr::one() - idx_delta)
        * val_delta
        * (Fr::one() - next_gate);

    out[15] = adj_match2 * wire(vals, Wire::QArith) * wire(vals, Wire::QAux) * d;
    out[16] = idx_inc * wire(vals, Wire::QArith) * wire(vals, Wire::QAux) * d;
    out[17] = (next_gate * next_gate - next_gate) * wire(vals, Wire::QArith) * wire(vals, Wire::QAux) * d;

    let rom_consistency = mr * wire(vals, Wire::Ql) * wire(vals, Wire::Qr);
    let ram_timestamp = (Fr::one() - idx_delta + idx_delta)
        * (wire(vals, Wire::WrShift) - wire(vals, Wire::Wr))
        - wire(vals, Wire::Wo);
    let ram_consistency = access_check * wire(vals, Wire::QArith);

    let memory_identity = rom_consistency
        + ram_timestamp * wire(vals, Wire::Q4) * wire(vals, Wire::Ql)
        + mr * wire(vals, Wire::Qm) * wire(vals, Wire::Ql)
        + ram_consistency;

    out[12] = (memory_identity + non_native_field_identity + limb_acc_identity)
        * wire(vals, Wire::QAux)
        * d;
}

/// Accumulate Poseidon external (18..21) and internal (22..25) subrelations.
fn accumulate_poseidon(vals: &[Fr], out: &mut [Fr], d: Fr) {
    let s1 = wire(vals, Wire::Wl) + wire(vals, Wire::Ql);
    let s2 = wire(vals, Wire::Wr) + wire(vals, Wire::Qr);
    let s3 = wire(vals, Wire::Wo) + wire(vals, Wire::Qo);
    let s4 = wire(vals, Wire::W4) + wire(vals, Wire::Q4);

    let u1 = s1.pow(5);
    let u2 = s2.pow(5);
    let u3 = s3.pow(5);
    let u4 = s4.pow(5);

    let t0 = u1 + u2;
    let t1 = u3 + u4;
    let t2 = u2 + u2 + t1;
    let t3 = u4 + u4 + t0;

    let v4 = t1 + t1 + t1 + t1 + t3;
    let v2 = t0 + t0 + t0 + t0 + t2;
    let v1 = t3 + v2;
    let v3 = t2 + v4;

    let qpos = wire(vals, Wire::QPoseidon2External);
    out[18] = (v1 - wire(vals, Wire::WlShift)) * qpos * d;
    out[19] = (v2 - wire(vals, Wire::WrShift)) * qpos * d;
    out[20] = (v3 - wire(vals, Wire::WoShift)) * qpos * d;
    out[21] = (v4 - wire(vals, Wire::W4Shift)) * qpos * d;

    let ipos = wire(vals, Wire::QPoseidon2Internal);
    let u_sum = u1 + u2 + u3 + u4;
    let diag = internal_matrix_diagonal();

    let w1 = u1 * diag[0] + u_sum;
    let w2 = u2 * diag[1] + u_sum;
    let w3 = u3 * diag[2] + u_sum;
    let w4 = u4 * diag[3] + u_sum;

    out[22] = (w1 - wire(vals, Wire::WlShift)) * ipos * d;
    out[23] = (w2 - wire(vals, Wire::WrShift)) * ipos * d;
    out[24] = (w3 - wire(vals, Wire::WoShift)) * ipos * d;
    out[25] = (w4 - wire(vals, Wire::W4Shift)) * ipos * d;
}

/// Batch all NUM_SUBRELATIONS = 26 subrelations with the alpha challenges.
fn batch_subrelations(evals: &[Fr], alphas: &[Fr]) -> Fr {
    let mut acc = evals[0];
    for (i, alpha) in alphas.iter().enumerate() {
        acc = acc + evals[i + 1] * *alpha;
    }
    acc
}

/// Main entrypoint: accumulate all subrelations and batch with alphas.
pub fn accumulate_relation_evaluations(
    vals: &[Fr],
    rp: &RelationParameters,
    alphas: &[Fr],
    pow_partial: Fr,
) -> Fr {
    const NUM_SUBRELATIONS: usize = 26;
    let mut out = vec![Fr::zero(); NUM_SUBRELATIONS];
    let d = pow_partial;

    accumulate_arithmetic(vals, &mut out, d);
    accumulate_permutation(vals, rp, &mut out, d);
    accumulate_lookup(vals, rp, &mut out, d);
    accumulate_range(vals, &mut out, d);
    accumulate_elliptic(vals, &mut out, d);
    accumulate_aux(vals, rp, &mut out, d);
    accumulate_poseidon(vals, &mut out, d);

    batch_subrelations(&out, alphas)
}

// src/shplonk.rs

use crate::field::Fr;
use crate::types::{G1Point, VerificationKey, Proof, Transcript};
use ark_bn254::{Bn254, G1Affine, G1Projective, G2Projective, Fq, Fq2};
use ark_ec::{CurveGroup, PrimeGroup};
use ark_ec::pairing::Pairing;
use ark_ff::{Zero, One};
use std::str::FromStr;
use std::ops::Mul;

pub const NUMBER_UNSHIFTED: usize = 35;
pub const NUMBER_SHIFTED:   usize = 5;   // = 40 - 35

/// Negate a G1 point (needed for moving quotient commitment to the other side).
fn negate(pt: &G1Point) -> G1Point {
    let proj = G1Projective::from(G1Affine::new_unchecked(pt.x, pt.y));
    let neg_affine = (-proj).into_affine();
    G1Point { x: neg_affine.x, y: neg_affine.y }
}

/// Multi‐scalar‐multiply on G1: ∑ scalars[i] * coms[i].
fn batch_mul(coms: &[G1Point], scalars: &[Fr]) -> G1Point {
    let mut acc = G1Projective::zero();
    for (c, s) in coms.iter().zip(scalars.iter()) {
        if !s.is_zero() {
            let pg = G1Affine::new_unchecked(c.x, c.y);
            acc += pg.mul(s.0);
        }
    }
    let a = acc.into_affine();
    G1Point { x: a.x, y: a.y }
}

/// Perform the final pairing check e(P0, G2)·e(P1, vk_g2) == 1.
fn pairing_check(p0: &G1Point, p1: &G1Point) -> bool {
    // standard BN254 G2 generator
    let g2 = G2Projective::generator().into_affine();
    // hardcoded second G2 from TS verifier
    let vk_g2 = G2Projective::new(
        Fq2::new(
            Fq::from_str("0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1").unwrap(),
            Fq::from_str("0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed").unwrap(),
        ),
        Fq2::new(
            Fq::from_str("0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b").unwrap(),
            Fq::from_str("0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa").unwrap(),
        ),
        Fq2::one(),
    )
    .into_affine();

    let g1_p0 = G1Affine::new_unchecked(p0.x, p0.y);
    let g1_p1 = G1Affine::new_unchecked(p1.x, p1.y);
    let e1 = Bn254::pairing(g1_p0, g2);
    let e2 = Bn254::pairing(g1_p1, vk_g2);
    e1.0 * e2.0 == <Bn254 as Pairing>::TargetField::one()
}

/// Verify Shplonk: batch all checks into one MSM+pairing.
pub fn verify_shplonk(
    proof: &Proof,
    vk: &VerificationKey,
    tx: &Transcript,
) -> Result<(), String> {
    let log_n = vk.log_circuit_size as usize;
    let n_sum = proof.sumcheck_evaluations.len(); // should be 40

    // 1) Precompute r^(2^i)
    let mut powers = Vec::with_capacity(log_n);
    powers.push(tx.gemini_r);
    for i in 1..log_n {
        powers.push(powers[i - 1] * powers[i - 1]);
    }

    // 2) Prepare arrays: 1 Q, n_sum evals, VK+proof commitments (40), log_n folds, const, quotient
    let total = 1 + n_sum + 40 + log_n + 1 + 1;
    let mut scalars = vec![Fr::zero(); total];
    let mut coms    = vec![G1Point { x: Fq::zero(), y: Fq::zero() }; total];

    // 3) Compute the "unshifted" / "shifted" batching scalars (pos/neg inverses)
    let pos0 = (tx.shplonk_z - powers[0]).inverse();
    let neg0 = (tx.shplonk_z + powers[0]).inverse();
    let unshifted = pos0 + tx.shplonk_nu * neg0;
    let shifted   = tx.gemini_r.inverse() * (pos0 - tx.shplonk_nu * neg0);

    // 4) Index 0 ← shplonk_Q
    scalars[0] = Fr::one();
    coms[0]    = proof.shplonk_q.clone();

    // 5) Batch sumcheck_evaluations with ρ–powers
    let mut running = Fr::one();
    let mut acc_eval = Fr::zero();
    // unshifted over first half
    for i in 0..NUMBER_UNSHIFTED {           // 0..34
        let idx = 1 + i;
        scalars[idx] = (-unshifted) * running;
        acc_eval = acc_eval + proof.sumcheck_evaluations[i] * running;
        running = running * tx.rho;
    }
    // shifted over second half
    for i in NUMBER_UNSHIFTED..n_sum {       // 35..39
        let idx = 1 + i;
        scalars[idx] = (-shifted) * running;
        acc_eval = acc_eval + proof.sumcheck_evaluations[i] * running;
        running = running * tx.rho;
    }

    // 6) Load all VK commitments (selectors, wires, tables, Lagrange)
    let mut i = 1 + n_sum;
    macro_rules! load_vk { ($field:ident) => {
        coms[i] = vk.$field.clone(); i += 1;
    }}
    load_vk!(qm); load_vk!(qc); load_vk!(ql); load_vk!(qr);
    load_vk!(qo); load_vk!(q4); load_vk!(q_lookup); load_vk!(q_arith);
    load_vk!(q_range); load_vk!(q_aux); load_vk!(q_elliptic);
    load_vk!(q_poseidon2_external); load_vk!(q_poseidon2_internal);
    load_vk!(s1); load_vk!(s2); load_vk!(s3); load_vk!(s4);
    load_vk!(id1); load_vk!(id2); load_vk!(id3); load_vk!(id4);
    load_vk!(t1); load_vk!(t2); load_vk!(t3); load_vk!(t4);
    load_vk!(lagrange_first); load_vk!(lagrange_last);

    // 7) Load proof's wire & lookup commitments
    coms[i] = proof.w1.clone(); i += 1;
    coms[i] = proof.w2.clone(); i += 1;
    coms[i] = proof.w3.clone(); i += 1;
    coms[i] = proof.w4.clone(); i += 1;
    coms[i] = proof.z_perm.clone(); i += 1;
    coms[i] = proof.lookup_inverses.clone(); i += 1;
    coms[i] = proof.lookup_read_counts.clone(); i += 1;
    coms[i] = proof.lookup_read_tags.clone(); i += 1;

    // 8) Load "shifted" wire commitments (same order)
    coms[i] = proof.w1.clone(); i += 1;
    coms[i] = proof.w2.clone(); i += 1;
    coms[i] = proof.w3.clone(); i += 1;
    coms[i] = proof.w4.clone(); i += 1;
    coms[i] = proof.z_perm.clone(); i += 1;

    // 9) Gemini folding: compute fold‐position evaluations
    let mut fold_pos = vec![Fr::zero(); log_n];
    let mut cur_acc  = acc_eval;
    for j in (1..=log_n).rev() {
        let r2 = powers[j - 1];
        let u  = tx.sumcheck_u_challenges[j - 1];
        let num = r2 * cur_acc * Fr::from_u64(2)
            - proof.gemini_a_evaluations[j - 1] * (r2 * (Fr::one() - u) - u);
        let den = r2 * (Fr::one() - u) + u;
        let next = num * den.inverse();
        fold_pos[j - 1] = next;
        cur_acc = next;
    }

    // 10) Constant‐term accumulation
    let mut const_acc = fold_pos[0] * pos0
        + proof.gemini_a_evaluations[0] * tx.shplonk_nu * neg0;
    running = tx.shplonk_nu * tx.shplonk_nu;

    // 11) Fold commitments
    let base = 1 + n_sum + 40;
    for j in 1..log_n {
        let pi = powers[j];
        let pos_i = (tx.shplonk_z - pi).inverse();
        let neg_i = (tx.shplonk_z + pi).inverse();
        let sp = running * pos_i;
        let sn = running * tx.shplonk_nu * neg_i;
        let idx = base + (j - 1);
        scalars[idx] = (-sp) + (-sn);
        const_acc = const_acc + proof.gemini_a_evaluations[j] * sn + fold_pos[j] * sp;
        running   = running * tx.shplonk_nu * tx.shplonk_nu;
        coms[idx] = proof.gemini_fold_comms[j - 1].clone();
    }

    // 12) "1‐point" at G1::one() and its scalar = const_acc
    let const_idx = 1 + n_sum + 40 + log_n;
    let gen = G1Projective::generator();
    coms[const_idx]    = G1Point { x: gen.x, y: gen.y };
    scalars[const_idx] = const_acc;

    // 13) Quotient commitment at last index, scalar = z
    let q_idx = const_idx + 1;
    coms[q_idx]    = proof.kzg_quotient.clone();
    scalars[q_idx] = tx.shplonk_z;

    // 14) Run MSM + pairing
    let p0 = batch_mul(&coms, &scalars);
    let p1 = negate(&proof.kzg_quotient);
    if pairing_check(&p0, &p1) {
        Ok(())
    } else {
        Err("Shplonk pairing check failed".into())
    }
}


//! Sumcheck verification

use crate::field::Fr;
use crate::relations::accumulate_relation_evaluations;
use crate::types::{Transcript, VerificationKey};
use lazy_static::lazy_static;

lazy_static! {
    /// Barycentric Lagrange denominators for 8‐point domain (from TS).
    static ref BARYCENTRIC_LAGRANGE_DENOMINATORS: [Fr; 8] = [
        Fr::from_str("0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffec51"),
        Fr::from_str("0x00000000000000000000000000000000000000000000000000000000000002d0"),
        Fr::from_str("0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffff11"),
        Fr::from_str("0x0000000000000000000000000000000000000000000000000000000000000090"),
        Fr::from_str("0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffff71"),
        Fr::from_str("0x00000000000000000000000000000000000000000000000000000000000000f0"),
        Fr::from_str("0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effffd31"),
        Fr::from_str("0x00000000000000000000000000000000000000000000000000000000000013b0"),
    ];
}

/// Check that round_univar[0] + round_univar[1] == target.
fn check_sum(round_univar: &[Fr], target: Fr) -> bool {
    let sum = round_univar[0] + round_univar[1];
    sum == target
}

/// Compute next sumcheck target via barycentric formula.
fn compute_next_target(round_univar: &[Fr], challenge: Fr) -> Fr {
    // numerator = ∏_{i=0..7}(challenge − i)
    let mut numerator = Fr::one();
    for i in 0..8 {
        numerator = numerator * (challenge - Fr::from_u64(i));
    }

    // Σ u_i / (D_i · (challenge − i))  =  Σ u_i · ((D_i · (challenge − i))⁻¹)
    let mut accumulator = Fr::zero();
    for i in 0..8u64 {
        let denom = BARYCENTRIC_LAGRANGE_DENOMINATORS[i as usize] * (challenge - Fr::from_u64(i));
        let inv   = denom.inverse();                    // 1 / (D_i · (challenge − i))
        accumulator = accumulator + round_univar[i as usize] * inv;
    }

    numerator * accumulator
}

/// Update running "pow_partial_eval" for each round.
fn update_pow_partial(eval: Fr, gate_ch: Fr, challenge: Fr) -> Fr {
    let term = Fr::one() + (challenge * (gate_ch - Fr::one()));
    eval * term
}

/// Verify the sumcheck phase. Returns Err(msg) on failure.
pub fn verify_sumcheck(
    proof: &crate::types::Proof,
    tx: &Transcript,
    vk: &VerificationKey,
) -> Result<(), String> {
    let mut target = Fr::zero();
    let mut pow_partial = Fr::one();
    let log_n = vk.log_circuit_size as usize;

    // 1) Check each round's low-degree sum and prepare next target
    for round in 0..log_n {
        let univar = &proof.sumcheck_univariates[round];
        if !check_sum(univar, target) {
            return Err(format!("Sumcheck first-pass failed at round {}", round));
        }
        let challenge = tx.sumcheck_u_challenges[round];
        target = compute_next_target(univar, challenge);
        pow_partial = update_pow_partial(pow_partial, tx.gate_challenges[round], challenge);
    }

    // 2) Accumulate all relation evaluations and compare with target
    let grand = accumulate_relation_evaluations(
        &proof.sumcheck_evaluations,
        &tx.rel_params,
        &tx.alphas,
        pow_partial,
    );

    if grand != target {
        Err("Final relation aggregate ≠ sumcheck target".into())
    } else {
        Ok(())
    }
}

//! Fiat–Shamir transcript for UltraHonk  (Rust ⇔ TS 完全一致)

use crate::{
    crypto::keccak256,
    field::Fr,
    types::{Proof, RelationParameters, Transcript, CONST_PROOF_SIZE_LOG_N},
    utils::fq_to_halves_be,
};
use ark_bn254::G1Affine;
use hex;                               // ←★追加

/* ───── helper ───── */

fn push_point(buf: &mut Vec<u8>, pt: &G1Affine) {
    let (x_lo, x_hi) = fq_to_halves_be(&pt.x);
    let (y_lo, y_hi) = fq_to_halves_be(&pt.y);
    buf.extend_from_slice(&x_lo);
    buf.extend_from_slice(&x_hi);
    buf.extend_from_slice(&y_lo);
    buf.extend_from_slice(&y_hi);
}

fn split(fr: Fr) -> (Fr, Fr) {
    let b = fr.to_bytes();
    let mut lo = [0u8; 32];
    lo[16..].copy_from_slice(&b[16..]);
    let mut hi = [0u8; 32];
    hi[16..].copy_from_slice(&b[..16]);
    (Fr::from_bytes(&lo), Fr::from_bytes(&hi))
}

#[inline(always)]
fn hash_to_fr(bytes: &[u8]) -> Fr {
    Fr::from_bytes(&keccak256(bytes))
}

fn u64_to_be32(x: u64) -> [u8; 32] {
    let mut out = [0u8; 32];
    out[24..].copy_from_slice(&x.to_be_bytes());
    out
}

/* ───── (★) デバッグ用ユーティリティ ───── */

#[inline(always)]
fn dbg_fr(tag: &str, x: &Fr) {
    println!("{:<18}: 0x{}", tag, hex::encode(x.to_bytes()));
}
#[inline(always)]
fn dbg_vec(tag: &str, xs: &[Fr]) {
    for (i, v) in xs.iter().enumerate() {
        println!("{tag}[{i:02}] = 0x{}", hex::encode(v.to_bytes()), tag = tag, i = i);
    }
}

/* ───── ① η ───── */

fn gen_eta(
    proof: &Proof,
    pub_inputs: &[Vec<u8>],
    cs: u64,
    pis: u64,
    offset: u64,
) -> (RelationParameters, Fr) {
    let mut data = Vec::new();
    data.extend_from_slice(&u64_to_be32(cs));
    data.extend_from_slice(&u64_to_be32(pis));
    data.extend_from_slice(&u64_to_be32(offset));
    for pi in pub_inputs {
        data.extend_from_slice(pi);
    }
    for w in &[&proof.w1, &proof.w2, &proof.w3] {
        push_point(&mut data, &w.to_affine());
    }

    let h = hash_to_fr(&data);
    let (eta, eta_two) = split(h);
    let h2 = hash_to_fr(&h.to_bytes());
    let (eta_three, _) = split(h2);

    (
        RelationParameters {
            eta,
            eta_two,
            eta_three,
            beta: Fr::zero(),
            gamma: Fr::zero(),
            public_inputs_delta: Fr::zero(),
        },
        h2,
    )
}

/* ───── ② β, γ ───── */

fn gen_beta_gamma(prev: Fr, proof: &Proof) -> (Fr, Fr, Fr) {
    let mut data = prev.to_bytes().to_vec();
    for w in &[&proof.lookup_read_counts, &proof.lookup_read_tags, &proof.w4] {
        push_point(&mut data, &w.to_affine());
    }
    let h = hash_to_fr(&data);
    let (beta, gamma) = split(h);
    (beta, gamma, h)
}

/* ───── ③ α’s (修正ポイント) ───── */

fn gen_alphas(prev: Fr, proof: &Proof) -> (Vec<Fr>, Fr) {
    let mut data = prev.to_bytes().to_vec();
    for w in &[&proof.lookup_inverses, &proof.z_perm] {
        push_point(&mut data, &w.to_affine());
    }
    let mut cur = hash_to_fr(&data);

    let mut alphas = Vec::with_capacity(25);
    let (a0, a1) = split(cur);
    alphas.push(a0);
    alphas.push(a1);

    while alphas.len() < 25 {
        cur = hash_to_fr(&cur.to_bytes());
        let (lo, hi) = split(cur);
        alphas.push(lo);
        if alphas.len() < 25 {
            alphas.push(hi);
        }
    }
    (alphas, cur)
}

/* ───── ④ gate / u challenges ───── */

fn gen_challenges(mut cur: Fr, rounds: usize) -> (Vec<Fr>, Fr) {
    let mut out = Vec::with_capacity(rounds);
    for _ in 0..rounds {
        cur = hash_to_fr(&cur.to_bytes());
        out.push(split(cur).0);
    }
    (out, cur)
}

/* ───── transcript main ───── */

pub fn generate_transcript(
    proof: &Proof,
    pub_inputs: &[Vec<u8>],
    cs: u64,
    pis: u64,
    offset: u64,
) -> Transcript {
    // 1) η
    let (mut rp, mut cur) = gen_eta(proof, pub_inputs, cs, pis, offset);

    // 2) β, γ
    let (beta, gamma, tmp) = gen_beta_gamma(cur, proof);
    rp.beta = beta;
    rp.gamma = gamma;
    cur = tmp;

    // 3) α’s
    let (alphas, tmp) = gen_alphas(cur, proof);
    cur = tmp;

    // 4) gate challenges
    let (gate_chals, tmp) = gen_challenges(cur, CONST_PROOF_SIZE_LOG_N);
    cur = tmp;

    // 5) sumcheck u challenges
    let (u_chals, tmp) = {
        let mut t = cur;
        let mut vs = Vec::with_capacity(CONST_PROOF_SIZE_LOG_N);
        for r in 0..CONST_PROOF_SIZE_LOG_N {
            let mut d = t.to_bytes().to_vec();
            for &c in &proof.sumcheck_univariates[r] {
                d.extend_from_slice(&c.to_bytes());
            }
            t = hash_to_fr(&d);
            vs.push(split(t).0);
        }
        (vs, t)
    };
    cur = tmp;

    // 6) ρ
    let mut data = cur.to_bytes().to_vec();
    for &e in &proof.sumcheck_evaluations {
        data.extend_from_slice(&e.to_bytes());
    }
    let rho = split(hash_to_fr(&data)).0;
    cur = hash_to_fr(&data);

    // 7) gemini_r
    let mut data = cur.to_bytes().to_vec();
    for pt in &proof.gemini_fold_comms {
        push_point(&mut data, &pt.to_affine());
    }
    let gemini_r = split(hash_to_fr(&data)).0;
    cur = hash_to_fr(&data);

    // 8) shplonk_nu
    let mut data = cur.to_bytes().to_vec();
    for &a in &proof.gemini_a_evaluations {
        data.extend_from_slice(&a.to_bytes());
    }
    let shplonk_nu = split(hash_to_fr(&data)).0;
    cur = hash_to_fr(&data);

    // 9) shplonk_z
    let mut data = cur.to_bytes().to_vec();
    push_point(&mut data, &proof.shplonk_q.to_affine());
    let shplonk_z = split(hash_to_fr(&data)).0;

    /* ───── (★) DEBUG DUMP ───── */
    println!("===== TRANSCRIPT (Rust) =====");
    dbg_fr ("eta"      , &rp.eta);
    dbg_fr ("eta_two"  , &rp.eta_two);
    dbg_fr ("eta_three", &rp.eta_three);
    dbg_fr ("beta"     , &rp.beta);
    dbg_fr ("gamma"    , &rp.gamma);
    dbg_vec("alpha"    , &alphas);
    dbg_vec("gate_ch"  , &gate_chals);
    dbg_vec("u_ch"     , &u_chals);
    dbg_fr ("rho"         , &rho);
    dbg_fr ("gemini_r"    , &gemini_r);
    dbg_fr ("shplonk_nu"  , &shplonk_nu);
    dbg_fr ("shplonk_z"   , &shplonk_z);
    println!("=============================");

    Transcript {
        rel_params: rp,
        alphas,
        gate_challenges: gate_chals,
        sumcheck_u_challenges: u_chals,
        rho,
        gemini_r,
        shplonk_nu,
        shplonk_z,
    }
}


//type.rs
use crate::field::Fr;
use ark_bn254::{Fq, G1Affine};

/// Number of subrelations in the Ultra Honk protocol.
pub const NUMBER_OF_SUBRELATIONS: usize = 26;
pub const CONST_PROOF_SIZE_LOG_N: usize = 28;

/// Wire indices for the Ultra Honk protocol.
#[derive(Copy, Clone, Debug)]
pub enum Wire {
    Qm = 0,
    Qc = 1,
    Ql = 2,
    Qr = 3,
    Qo = 4,
    Q4 = 5,
    QLookup = 6,
    QArith = 7,
    QRange = 8,
    QElliptic = 9,
    QAux = 10,
    QPoseidon2External = 11,
    QPoseidon2Internal = 12,
    Sigma1 = 13,
    Sigma2 = 14,
    Sigma3 = 15,
    Sigma4 = 16,
    Id1 = 17,
    Id2 = 18,
    Id3 = 19,
    Id4 = 20,
    Table1 = 21,
    Table2 = 22,
    Table3 = 23,
    Table4 = 24,
    LagrangeFirst = 25,
    LagrangeLast = 26,
    Wl = 27,
    Wr = 28,
    Wo = 29,
    W4 = 30,
    ZPerm = 31,
    LookupInverses = 32,
    LookupReadCounts = 33,
    LookupReadTags = 34,
    WlShift = 35,
    WrShift = 36,
    WoShift = 37,
    W4Shift = 38,
    ZPermShift = 39,
}

impl Wire {
    pub fn index(&self) -> usize {
        *self as usize
    }
}

/// A G1 point in affine coordinates.
#[derive(Clone, Debug)]
pub struct G1Point {
    pub x: Fq,
    pub y: Fq,
}

impl G1Point {
    /// Convert an ark_ec-affine point into our wrapper.
    pub fn from_affine(pt: &G1Affine) -> Self {
        G1Point {
            x: pt.x,
            y: pt.y,
        }
    }

    /// Convert back to ark_ec-affine for pairing.
    pub fn to_affine(&self) -> G1Affine {
        G1Affine::new(self.x, self.y)
    }
}

/// The verification key structure, matching TS's VerificationKey interface.
#[derive(Clone, Debug)]
pub struct VerificationKey {
    pub circuit_size: u64,
    pub log_circuit_size: u64,
    pub public_inputs_size: u64,
    // Selectors and wire commitments:
    pub qm: G1Point,
    pub qc: G1Point,
    pub ql: G1Point,
    pub qr: G1Point,
    pub qo: G1Point,
    pub q4: G1Point,
    pub q_lookup: G1Point,
    pub q_arith: G1Point,
    pub q_range: G1Point,
    pub q_aux: G1Point,
    pub q_elliptic: G1Point,
    pub q_poseidon2_external: G1Point,
    pub q_poseidon2_internal: G1Point,
    // Copy constraints:
    pub s1: G1Point,
    pub s2: G1Point,
    pub s3: G1Point,
    pub s4: G1Point,
    pub id1: G1Point,
    pub id2: G1Point,
    pub id3: G1Point,
    pub id4: G1Point,
    // Lookup table commitments:
    pub t1: G1Point,
    pub t2: G1Point,
    pub t3: G1Point,
    pub t4: G1Point,
    // Fixed first/last
    pub lagrange_first: G1Point,
    pub lagrange_last: G1Point,
}

/// The Proof structure, matching TS's Proof interface.
#[derive(Clone, Debug)]
pub struct Proof {
    // Wire commitments
    pub w1: G1Point,
    pub w2: G1Point,
    pub w3: G1Point,
    pub w4: G1Point,
    // Lookup helpers
    pub lookup_read_counts: G1Point,
    pub lookup_read_tags: G1Point,
    pub lookup_inverses: G1Point,
    pub z_perm: G1Point,
    // Sumcheck polynomials
    pub sumcheck_univariates: Vec<Vec<Fr>>, // 28 × 8
    pub sumcheck_evaluations: Vec<Fr>,      // 40
    // Gemini fold commitments
    pub gemini_fold_comms: Vec<G1Point>,    // 27
    pub gemini_a_evaluations: Vec<Fr>,      // 28
    // Shplonk
    pub shplonk_q: G1Point,
    pub kzg_quotient: G1Point,
}

/// Relation parameters (η, η₂, η₃, β, γ, public_inputs_delta).
#[derive(Clone, Debug)]
pub struct RelationParameters {
    pub eta: Fr,
    pub eta_two: Fr,
    pub eta_three: Fr,
    pub beta: Fr,
    pub gamma: Fr,
    pub public_inputs_delta: Fr,
}

/// The transcript holding all Fiat–Shamir challenges.
#[derive(Clone, Debug)]
pub struct Transcript {
    pub rel_params: RelationParameters,
    pub alphas: Vec<Fr>,            // 25
    pub gate_challenges: Vec<Fr>,   // logN (28)
    pub sumcheck_u_challenges: Vec<Fr>, // 28
    pub rho: Fr,
    pub gemini_r: Fr,
    pub shplonk_nu: Fr,
    pub shplonk_z: Fr,
}

// utils.rs
//! Utilities for loading Proof and VerificationKey, plus byte↔field/point conversion.

use crate::field::Fr;
use crate::types::{G1Point, VerificationKey, Proof};
use ark_bn254::Fq;
use std::fs::File;
use std::io::Read;
use num_bigint::BigUint;
use num_traits::Num;
use ark_ff::{PrimeField, BigInteger256};

/// Convert 32 bytes into an Fr.
fn bytes_to_fr(bytes: &[u8; 32]) -> Fr {
    Fr::from_bytes(bytes)
}

/// Big-Endian 32 byte → Fq （mod p で受け入れる）
fn fq_from_be_bytes(bytes_be: &[u8; 32]) -> Fq {
    let mut bytes_le = *bytes_be;   // 32-byte copy
    bytes_le.reverse();             // BE → LE
    Fq::from_le_bytes_mod_order(&bytes_le)
}


/// Fq → 32-byte big-endian
pub fn fq_to_be_bytes(f: &Fq) -> [u8; 32] {
    let mut out = [0u8; 32];
    let bi: BigInteger256 = (*f).into();          // 4 × 64-bit limbs (LE)
    for (i, limb) in bi.0.iter().rev().enumerate() {
        out[i * 8..(i + 1) * 8].copy_from_slice(&limb.to_be_bytes());
    }
    out
}

/// Fq → (low136, high120) それぞれ 32-byte BE
pub fn fq_to_halves_be(f: &Fq) -> ([u8; 32], [u8; 32]) {
    let be = fq_to_be_bytes(f);
    let big = BigUint::from_bytes_be(&be);
    let mask = (BigUint::from(1u8) << 136) - 1u8;   // 2¹³⁶ − 1
    let low = &big & &mask;                         // 下 136 bit
    let high = &big >> 136;                         // 上 120 bit

    // biguint → 32-byte BE
    fn to_arr(x: BigUint) -> [u8; 32] {
        let mut arr = [0u8; 32];
        let bytes = x.to_bytes_be();
        arr[32 - bytes.len()..].copy_from_slice(&bytes);
        arr
    }

    (to_arr(low), to_arr(high))
}

/// Convert 128 bytes into a G1Point.
/// The layout is four consecutive 32‐byte chunks: x_low, x_high, y_low, y_high.
/// We reconstruct a 256-bit coordinate by shifting high<<136 + low.
fn bytes_to_g1_point(bytes: &[u8]) -> G1Point {
    assert_eq!(bytes.len(), 128);
    // Parse low/high for x:
    let x_low = BigUint::from_bytes_be(&bytes[0..32]);
    let x_high = BigUint::from_bytes_be(&bytes[32..64]);
    // Parse low/high for y:
    let y_low = BigUint::from_bytes_be(&bytes[64..96]);
    let y_high = BigUint::from_bytes_be(&bytes[96..128]);

    // Combine: high << 136 bits, plus low.
    let shift_bits = 136u32;
    let big_x = (x_high << shift_bits) | x_low;
    let big_y = (y_high << shift_bits) | y_low;

    // Convert BigUint -> 32 bytes → Fq
    let x_bytes = big_x.to_bytes_be();
    let mut x_arr = [0u8; 32];
    x_arr[32 - x_bytes.len()..].copy_from_slice(&x_bytes);
    let fq_x = fq_from_be_bytes(&x_arr);

    let y_bytes = big_y.to_bytes_be();
    let mut y_arr = [0u8; 32];
    y_arr[32 - y_bytes.len()..].copy_from_slice(&y_bytes);
    let fq_y = fq_from_be_bytes(&y_arr);

    G1Point { x: fq_x, y: fq_y }
}

/// Load a Proof from a byte array (e.g. read from proof.bin).
pub fn load_proof(proof_bytes: &[u8]) -> Proof {
    let mut cursor = 0usize;

    // Helper: read next 128 bytes as G1Point
    fn read_g1(bytes: &[u8], cur: &mut usize) -> G1Point {
        let pt = bytes_to_g1_point(&bytes[*cur..*cur + 128]);
        *cur += 128;
        pt
    }

    // Helper: read next 32 bytes as Fr
    fn read_fr(bytes: &[u8], cur: &mut usize) -> Fr {
        let mut arr = [0u8; 32];
        arr.copy_from_slice(&bytes[*cur..*cur + 32]);
        *cur += 32;
        bytes_to_fr(&arr)
    }

    // 1) w1, w2, w3
    let w1 = read_g1(proof_bytes, &mut cursor);
    let w2 = read_g1(proof_bytes, &mut cursor);
    let w3 = read_g1(proof_bytes, &mut cursor);

    // 2) lookup_read_counts, lookup_read_tags
    let lookup_read_counts = read_g1(proof_bytes, &mut cursor);
    let lookup_read_tags = read_g1(proof_bytes, &mut cursor);

    // 3) w4
    let w4 = read_g1(proof_bytes, &mut cursor);

    // 4) lookup_inverses, z_perm
    let lookup_inverses = read_g1(proof_bytes, &mut cursor);
    let z_perm = read_g1(proof_bytes, &mut cursor);

    // 5) sumcheck_univariates: 28 rounds × 8 Fr each
    let mut sumcheck_univariates = Vec::new();
    for _ in 0..28 {
        let mut row = Vec::with_capacity(8);
        for _ in 0..8 {
            row.push(read_fr(proof_bytes, &mut cursor));
        }
        sumcheck_univariates.push(row);
    }

    // 6) sumcheck_evaluations: 40 Fr
    let mut sumcheck_evaluations = Vec::new();
    for _ in 0..40 {
        sumcheck_evaluations.push(read_fr(proof_bytes, &mut cursor));
    }

    // 7) gemini_fold_comms: 27 G1Points
    let mut gemini_fold_comms = Vec::new();
    for _ in 0..27 {
        gemini_fold_comms.push(read_g1(proof_bytes, &mut cursor));
    }

    // 8) gemini_a_evaluations: 28 Fr
    let mut gemini_a_evaluations = Vec::new();
    for _ in 0..28 {
        gemini_a_evaluations.push(read_fr(proof_bytes, &mut cursor));
    }

    // 9) shplonk_q, kzg_quotient
    let shplonk_q = read_g1(proof_bytes, &mut cursor);
    let kzg_quotient = read_g1(proof_bytes, &mut cursor);

    Proof {
        w1,
        w2,
        w3,
        w4,
        lookup_read_counts,
        lookup_read_tags,
        lookup_inverses,
        z_perm,
        sumcheck_univariates,
        sumcheck_evaluations,
        gemini_fold_comms,
        gemini_a_evaluations,
        shplonk_q,
        kzg_quotient,
    }
}

/// Combine two consecutive 256-bit field elements (each represented as hex string) into a single BigUint.
/// TS logic: high_part (30 hex chars) ++ low_part (34 hex chars) = 64 hex chars total.
fn combine_fields(low_str: &str, high_str: &str) -> BigUint {
    // Both strings start with "0x", so strip that.
    let low_hex = low_str.trim_start_matches("0x");
    let high_hex = high_str.trim_start_matches("0x");

    // Parse low/high into BigUint
    let low = BigUint::from_str_radix(low_hex, 16).unwrap();
    let high = BigUint::from_str_radix(high_hex, 16).unwrap();

    // high << (34*4) bits = high << 136
    let combined = (high << 136) | low;
    combined
}

/// Load a VerificationKey from a JSON file containing an array of hex‐encoded field‐elements.
pub fn load_vk(path: &str) -> VerificationKey {
    // Read entire file as string
    let mut file = File::open(path).expect("VK JSON file not found");
    let mut data = String::new();
    file.read_to_string(&mut data).unwrap();

    // Parse JSON into Vec<String>
    let vk_fields: Vec<String> = serde_json::from_str(&data).unwrap();
    // Ensure we have at least the minimal length
    assert!(
        vk_fields.len() > 127,
        "VK JSON must contain at least 128 field elements"
    );

    // Parse circuit params:
    let circuit_size = BigUint::from_str_radix(
        vk_fields[0].trim_start_matches("0x"),
        16,
    )
    .unwrap()
    .to_u64_digits(); // But we know it's u64
    let circuit_size_u64 = circuit_size[0];
    let public_inputs_size = BigUint::from_str_radix(
        vk_fields[1].trim_start_matches("0x"),
        16,
    )
    .unwrap()
    .to_u64_digits()[0];
    let log_circuit_size = (circuit_size_u64 as f64).log2() as u64;

    // Helper to convert combined BigUint into an Fq
    fn biguint_to_fq(x: BigUint) -> Fq {
        let be = x.to_bytes_be();
        let mut arr = [0u8; 32];
        arr[32 - be.len()..].copy_from_slice(&be);
        fq_from_be_bytes(&arr)
    }

    // Starting index for G1 points: 20
    let mut field_index = 20;

    macro_rules! read_g1 {
        () => {{
            // Each G1Point uses 4 consecutive fields: low_x, high_x, low_y, high_y
            let low_x = &vk_fields[field_index];
            let high_x = &vk_fields[field_index + 1];
            let low_y = &vk_fields[field_index + 2];
            let high_y = &vk_fields[field_index + 3];
            let big_x = combine_fields(low_x, high_x);
            let big_y = combine_fields(low_y, high_y);
            field_index += 4;
            G1Point {
                x: biguint_to_fq(big_x),
                y: biguint_to_fq(big_y),
            }
        }};
    }

    let qm = read_g1!();
    let qc = read_g1!();
    let ql = read_g1!();
    let qr = read_g1!();
    let qo = read_g1!();
    let q4 = read_g1!();
    let q_lookup = read_g1!();
    let q_arith = read_g1!();
    let q_range = read_g1!();
    let q_aux = read_g1!();
    let q_elliptic = read_g1!();
    let q_poseidon2_external = read_g1!();
    let q_poseidon2_internal = read_g1!();
    let s1 = read_g1!();
    let s2 = read_g1!();
    let s3 = read_g1!();
    let s4 = read_g1!();
    let id1 = read_g1!();
    let id2 = read_g1!();
    let id3 = read_g1!();
    let id4 = read_g1!();
    let t1 = read_g1!();
    let t2 = read_g1!();
    let t3 = read_g1!();
    let t4 = read_g1!();
    let lagrange_first = read_g1!();
    let lagrange_last = read_g1!();

    VerificationKey {
        circuit_size: circuit_size_u64,
        log_circuit_size,
        public_inputs_size,
        qm,
        qc,
        ql,
        qr,
        qo,
        q4,
        q_lookup,
        q_arith,
        q_range,
        q_aux,
        q_elliptic,
        q_poseidon2_external,
        q_poseidon2_internal,
        s1,
        s2,
        s3,
        s4,
        id1,
        id2,
        id3,
        id4,
        t1,
        t2,
        t3,
        t4,
        lagrange_first,
        lagrange_last,
    }
}

/// Load a proof and public inputs from a byte array.
pub fn load_proof_and_public_inputs(bytes: &[u8]) -> (Vec<Fr>, Vec<u8>) {
    // First 4 bytes = total number of field elements (big-endian)
    let total_fields = u32::from_be_bytes(bytes[0..4].try_into().unwrap()) as usize;

    // Proof is always 440 field elements (TS layout)
    const PROOF_NUM_FIELDS: usize = 440;
    assert!(
        total_fields >= PROOF_NUM_FIELDS,
        "total_fields < proof field count"
    );
    let num_inputs = total_fields - PROOF_NUM_FIELDS;

    // Next num_inputs × 32 bytes = public inputs
    let mut public_inputs = Vec::with_capacity(num_inputs);
    let mut cursor = 4; // start right after the 4-byte header
    for _ in 0..num_inputs {
        let mut bytes32 = [0u8; 32];
        bytes32.copy_from_slice(&bytes[cursor..cursor + 32]);
        public_inputs.push(bytes_to_fr(&bytes32));
        cursor += 32;
    }

    // Remaining bytes = proof (must be 440 × 32 bytes)
    let proof_bytes = bytes[cursor..].to_vec();
    assert!(
        proof_bytes.len() == PROOF_NUM_FIELDS * 32,
        "invalid proof length"
    );

    (public_inputs, proof_bytes)
}

//! The main UltraHonk verifier

use crate::transcript::generate_transcript;
use crate::{utils::{load_proof, load_vk}, sumcheck::verify_sumcheck, shplonk::verify_shplonk};
use crate::types::VerificationKey;
use crate::field::Fr;

/// High‐level verifier struct.
pub struct HonkVerifier {
    vk: VerificationKey,
}

impl HonkVerifier {
    /// Create from a VK JSON file.
    pub fn new(vk_path: &str) -> Self {
        let vk = load_vk(vk_path);
        HonkVerifier { vk }
    }

    /// Verify a proof and public inputs.
    pub fn verify(
        &self,
        proof_bytes: &[u8],
        public_inputs: &[Vec<u8>],
    ) -> Result<(), String> {
        // 1) load and parse proof
        let proof = load_proof(proof_bytes);

        // 2) check pub-inputs size
        if public_inputs.len() != self.vk.public_inputs_size as usize {
            return Err(format!(
                "Expected {} public inputs, got {}",
                self.vk.public_inputs_size,
                public_inputs.len()
            ));
        }

        // 3) generate transcript
        let mut tx = generate_transcript(
            &proof,
            public_inputs,
            self.vk.circuit_size,
            self.vk.public_inputs_size,
            1, // offset
        );

        // 4) compute public_inputs_delta and inject
        tx.rel_params.public_inputs_delta =
            self.compute_public_inputs_delta(
                public_inputs,
                tx.rel_params.beta,
                tx.rel_params.gamma,
                1,
                self.vk.circuit_size,
            );

        // 5) sumcheck
        verify_sumcheck(&proof, &tx, &self.vk)?;

        // 6) shplonk
        verify_shplonk(&proof, &self.vk, &tx)?;

        Ok(())
    }

    /// Compute public_inputs_delta exactly as TS's helper.
    fn compute_public_inputs_delta(
        &self,
        public_inputs: &[Vec<u8>],
        beta: Fr,
        gamma: Fr,
        offset: u64,
        circuit_size: u64,
    ) -> Fr {
        let mut num = Fr::one();
        let mut den = Fr::one();

        let mut num_acc = gamma + beta * Fr::from_u64(circuit_size + offset);
        let mut den_acc = gamma - beta * Fr::from_u64(offset + 1);

        for pi_bytes in public_inputs {
            let pi = Fr::from_bytes(
                &pi_bytes
                    .as_slice()
                    .try_into()
                    .expect("Each public input must be 32 bytes"),
            );
            num = num * (num_acc + pi);
            den = den * (den_acc + pi);
            num_acc = num_acc + beta;
            den_acc = den_acc - beta;
        }

        num.div(&den)
    }
}

